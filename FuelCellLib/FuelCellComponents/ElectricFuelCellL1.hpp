#ifndef ELECTRICFUELCELLL1_HPP_INCLUDED
#define ELECTRICFUELCELLL1_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file ElectricFuelCellL1.hpp
//! @author Petter Krus <petter.krus@liu.se>
//  co-author/auditor **Not yet audited by a second person**
//! @date Wed 11 Nov 2020 17:33:54
//! @brief Level 1 (conceptual) Fuel cell model with some dynamics
//! @ingroup ElectricComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, Users, petkr14, Dropbox, HopsanComponents, FuelCellLibrary, \
FuelCellComponents}/ElectricFuelcellL18.nb*/

using namespace hopsan;

class ElectricFuelCellL1 : public ComponentQ
{
private:
     double R;
     double cv;
     double kmFC;
     double nstack;
     double T;
     double Tref;
     double A;
     double l;
     double Ph2;
     double Po2;
     double P0;
     double Faraday;
     double dS;
     double dG;
     double B;
     double Rc;
     double Ch2;
     double ksi1;
     double ksi3;
     double ksi4;
     double psi;
     double Jmax;
     double Jn;
     double MH2;
     double cA;
     double thaucon;
     double timeComp;
     double e;
     Port *mpPfc;
     Port *mpPp1;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[5];
     int mNstep;
     //Port Pfc variable
     double ufc;
     double ifc;
     double cfc;
     double Zcfc;
     //Port Pp1 variable
     double pp1;
     double qmp1;
     double Tp1;
     double dEp1;
     double cp1;
     double Zcp1;
//==This code has been autogenerated using Compgen==
     //inputVariables
     double thetaFcRef;
     //outputVariables
     double mFC;
     double unernst;
     double uohmic;
     double uact;
     double ucon;
     double ufc0;
     double ufcr;
     double ufc1;
     double ifc0;
     double etaFC;
     double Powfc;
     double rhoM;
     double WH2;
     //LocalExpressions variables
     double cp;
     double Co2;
     double ksi2;
     double Rohmic;
     //Expressions variables
     //Port Pfc pointer
     double *mpP_ufc;
     double *mpP_ifc;
     double *mpP_cfc;
     double *mpP_Zcfc;
     //Port Pp1 pointer
     double *mpP_pp1;
     double *mpP_qmp1;
     double *mpP_Tp1;
     double *mpP_dEp1;
     double *mpP_cp1;
     double *mpP_Zcp1;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     double *mpthetaFcRef;
     //inputParameters pointers
     double *mpR;
     double *mpcv;
     double *mpkmFC;
     double *mpnstack;
     double *mpT;
     double *mpTref;
     double *mpA;
     double *mpl;
     double *mpPh2;
     double *mpPo2;
     double *mpP0;
     double *mpFaraday;
     double *mpdS;
     double *mpdG;
     double *mpB;
     double *mpRc;
     double *mpCh2;
     double *mpksi1;
     double *mpksi3;
     double *mpksi4;
     double *mppsi;
     double *mpJmax;
     double *mpJn;
     double *mpMH2;
     double *mpcA;
     double *mpthaucon;
     double *mptimeComp;
     double *mpe;
     //outputVariables pointers
     double *mpmFC;
     double *mpunernst;
     double *mpuohmic;
     double *mpuact;
     double *mpucon;
     double *mpufc0;
     double *mpufcr;
     double *mpufc1;
     double *mpifc0;
     double *mpetaFC;
     double *mpPowfc;
     double *mprhoM;
     double *mpWH2;
     Delay mDelayedPart10;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart31;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new ElectricFuelCellL1();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(5,5);
        systemEquations.create(5);
        delayedPart.create(6,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpPfc=addPowerPort("Pfc","NodeElectric");
        mpPp1=addPowerPort("Pp1","NodePneumatic");
        //Add inputVariables to the component
            addInputVariable("thetaFcRef","Power fraction reference \
[0,1]","",1.,&mpthetaFcRef);

        //Add inputParammeters to the component
            addInputVariable("R", "Gas constant", "J/Kg K", 4124.2,&mpR);
            addInputVariable("cv", "heatcoeff", "J/Kg K", 10183.,&mpcv);
            addInputVariable("kmFC", "Fuel cell spec. power", "W/kg", \
1000.,&mpkmFC);
            addInputVariable("nstack", "", "", 1,&mpnstack);
            addInputVariable("T", "", "K", 323,&mpT);
            addInputVariable("Tref", "", "K", 298.15,&mpTref);
            addInputVariable("A", "", "m2", 0.00625,&mpA);
            addInputVariable("l", "", "m", 0.000025,&mpl);
            addInputVariable("Ph2", "Hydrogen partial press", "atm", \
1.476,&mpPh2);
            addInputVariable("Po2", "Oxygen partial press", "atm", \
0.2095,&mpPo2);
            addInputVariable("P0", "", "atm", 1,&mpP0);
            addInputVariable("Faraday", "", "", 96485.3,&mpFaraday);
            addInputVariable("dS", "", "", 164.02501,&mpdS);
            addInputVariable("dG", "Gibbs free energy", "", 228000.6,&mpdG);
            addInputVariable("B", "", "V", 0.15,&mpB);
            addInputVariable("Rc", "", "", 0.0003,&mpRc);
            addInputVariable("Ch2", "", "", 0.2,&mpCh2);
            addInputVariable("ksi1", "", "", -0.948,&mpksi1);
            addInputVariable("ksi3", "", "", 0.0000722,&mpksi3);
            addInputVariable("ksi4", "", "", \
-0.00010640000000000001,&mpksi4);
            addInputVariable("psi", "", "", 23.,&mppsi);
            addInputVariable("Jmax", "Max current intensity", "A/m2", \
6720.,&mpJmax);
            addInputVariable("Jn", "", "A/m2", 220.,&mpJn);
            addInputVariable("MH2", "", "kg/mol", 0.002016,&mpMH2);
            addInputVariable("cA", "Capacitance", "F", 10.,&mpcA);
            addInputVariable("thaucon", "", "s", 0.1,&mpthaucon);
            addInputVariable("timeComp", "time compression factor.", "", \
1.,&mptimeComp);
            addInputVariable("e", "e", "", 2.71828,&mpe);
        //Add outputVariables to the component
            addOutputVariable("mFC","Mass of fuel cell","kg",1.,&mpmFC);
            addOutputVariable("unernst","","V",1.,&mpunernst);
            addOutputVariable("uohmic","","V",1,&mpuohmic);
            addOutputVariable("uact","","V",1,&mpuact);
            addOutputVariable("ucon","","V",1,&mpucon);
            addOutputVariable("ufc0","","V",1,&mpufc0);
            addOutputVariable("ufcr","","V",1,&mpufcr);
            addOutputVariable("ufc1","","V",1,&mpufc1);
            addOutputVariable("ifc0","","A",0.,&mpifc0);
            addOutputVariable("etaFC","Fuel cell efficiency","",0.,&mpetaFC);
            addOutputVariable("Powfc","","Power",0.,&mpPowfc);
            addOutputVariable("rhoM","","kg/m^3",0.,&mprhoM);
            addOutputVariable("WH2","","kg/s",0.,&mpWH2);

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,5);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pfc
        mpP_ufc=getSafeNodeDataPtr(mpPfc, NodeElectric::Voltage);
        mpP_ifc=getSafeNodeDataPtr(mpPfc, NodeElectric::Current);
        mpP_cfc=getSafeNodeDataPtr(mpPfc, NodeElectric::WaveVariable);
        mpP_Zcfc=getSafeNodeDataPtr(mpPfc, NodeElectric::CharImpedance);
        //Port Pp1
        mpP_pp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::Pressure);
        mpP_qmp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::MassFlow);
        mpP_Tp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::Temperature);
        mpP_dEp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::EnergyFlow);
        mpP_cp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::WaveVariable);
        mpP_Zcp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::CharImpedance);

        //Read variables from nodes
        //Port Pfc
        ufc = (*mpP_ufc);
        ifc = (*mpP_ifc);
        cfc = (*mpP_cfc);
        Zcfc = (*mpP_Zcfc);
        //Port Pp1
        pp1 = (*mpP_pp1);
        qmp1 = (*mpP_qmp1);
        Tp1 = (*mpP_Tp1);
        dEp1 = (*mpP_dEp1);
        cp1 = (*mpP_cp1);
        Zcp1 = (*mpP_Zcp1);

        //Read inputVariables from nodes
        thetaFcRef = (*mpthetaFcRef);

        //Read inputParameters from nodes
        R = (*mpR);
        cv = (*mpcv);
        kmFC = (*mpkmFC);
        nstack = (*mpnstack);
        T = (*mpT);
        Tref = (*mpTref);
        A = (*mpA);
        l = (*mpl);
        Ph2 = (*mpPh2);
        Po2 = (*mpPo2);
        P0 = (*mpP0);
        Faraday = (*mpFaraday);
        dS = (*mpdS);
        dG = (*mpdG);
        B = (*mpB);
        Rc = (*mpRc);
        Ch2 = (*mpCh2);
        ksi1 = (*mpksi1);
        ksi3 = (*mpksi3);
        ksi4 = (*mpksi4);
        psi = (*mppsi);
        Jmax = (*mpJmax);
        Jn = (*mpJn);
        MH2 = (*mpMH2);
        cA = (*mpcA);
        thaucon = (*mpthaucon);
        timeComp = (*mptimeComp);
        e = (*mpe);

        //Read outputVariables from nodes
        mFC = (*mpmFC);
        unernst = (*mpunernst);
        uohmic = (*mpuohmic);
        uact = (*mpuact);
        ucon = (*mpucon);
        ufc0 = (*mpufc0);
        ufcr = (*mpufcr);
        ufc1 = (*mpufc1);
        ifc0 = (*mpifc0);
        etaFC = (*mpetaFC);
        Powfc = (*mpPowfc);
        rhoM = (*mprhoM);
        WH2 = (*mpWH2);

//==This code has been autogenerated using Compgen==

        //LocalExpressions
        cp = cv + R;
        Co2 = 1.968503937007874e-7*Power(e,498/T)*Po2;
        ksi2 = 0.00286 + 0.0002*log(10000*A) + 0.000043*log(Ch2);
        rhoM = (181.6*(1 + (3.e-6*ifc0)/A + \
6.753150562581011e-7*Power(T,2)*Power(lowLimit(ifc0/(10000.*A),0.),2.5)))/(-0\
.634 - (3*Power(e,(4.18*(-303 + T))/T)*ifc0)/(10000.*A) + psi);
        unernst = dG/(2.*Faraday) + (dS*(T - Tref))/(2.*Faraday) + \
(R*T*log((Ph2*Sqrt(Po2))/P0))/(2.*Faraday);
        uact = lowLimit(-ksi1 - ksi2*T - ksi3*T*log(Co2) - \
ksi4*T*log(lowLimit(ifc0,9.999999999999999e-31)),0);
        ucon = (1.3*B*limit(ifc/(A*Jmax),0.,1.075))/(1 - \
0.7480520100000002*Power(limit(ifc/(A*Jmax),0.,1.075),4));
        uohmic = (ifc*l*rhoM)/(100.*A);
        Rohmic = (l*rhoM)/(100.*A);
        ufcr = lowLimit(-uact - ucon + unernst - uohmic,0.);
        ufc0 = lowLimit(-uact - ucon + unernst,0.);

        //Initialize delays
        delayParts2[1] = (-(mTimestep*ufc0) + mTimestep*ufc1 - \
2*thaucon*ufc1)/(mTimestep + 2*thaucon);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);
        delayParts3[1] = (-(ifc*mTimestep) + ifc0*mTimestep - \
2*ifc0*thaucon)/(mTimestep + 2*thaucon);
        mDelayedPart31.initialize(mNstep,delayParts3[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];

        simulateOneTimestep();

     }
    void simulateOneTimestep()
     {
        Vec stateVar(5);
        Vec stateVark(5);
        Vec deltaStateVar(5);

        //Read variables from nodes
        //Port Pfc
        cfc = (*mpP_cfc);
        Zcfc = (*mpP_Zcfc);
        //Port Pp1
        Tp1 = (*mpP_Tp1);
        cp1 = (*mpP_cp1);
        Zcp1 = (*mpP_Zcp1);

        //Read inputVariables from nodes
        thetaFcRef = (*mpthetaFcRef);

        //Read inputParameters from nodes
        R = (*mpR);
        cv = (*mpcv);
        kmFC = (*mpkmFC);
        nstack = (*mpnstack);
        T = (*mpT);
        Tref = (*mpTref);
        A = (*mpA);
        l = (*mpl);
        Ph2 = (*mpPh2);
        Po2 = (*mpPo2);
        P0 = (*mpP0);
        Faraday = (*mpFaraday);
        dS = (*mpdS);
        dG = (*mpdG);
        B = (*mpB);
        Rc = (*mpRc);
        Ch2 = (*mpCh2);
        ksi1 = (*mpksi1);
        ksi3 = (*mpksi3);
        ksi4 = (*mpksi4);
        psi = (*mppsi);
        Jmax = (*mpJmax);
        Jn = (*mpJn);
        MH2 = (*mpMH2);
        cA = (*mpcA);
        thaucon = (*mpthaucon);
        timeComp = (*mptimeComp);
        e = (*mpe);

        //LocalExpressions
        cp = cv + R;
        Co2 = 1.968503937007874e-7*Power(e,498/T)*Po2;
        ksi2 = 0.00286 + 0.0002*log(10000*A) + 0.000043*log(Ch2);
        rhoM = (181.6*(1 + (3.e-6*ifc0)/A + \
6.753150562581011e-7*Power(T,2)*Power(lowLimit(ifc0/(10000.*A),0.),2.5)))/(-0\
.634 - (3*Power(e,(4.18*(-303 + T))/T)*ifc0)/(10000.*A) + psi);
        unernst = dG/(2.*Faraday) + (dS*(T - Tref))/(2.*Faraday) + \
(R*T*log((Ph2*Sqrt(Po2))/P0))/(2.*Faraday);
        uact = lowLimit(-ksi1 - ksi2*T - ksi3*T*log(Co2) - \
ksi4*T*log(lowLimit(ifc0,9.999999999999999e-31)),0);
        ucon = (1.3*B*limit(ifc/(A*Jmax),0.,1.075))/(1 - \
0.7480520100000002*Power(limit(ifc/(A*Jmax),0.,1.075),4));
        uohmic = (ifc*l*rhoM)/(100.*A);
        Rohmic = (l*rhoM)/(100.*A);
        ufcr = lowLimit(-uact - ucon + unernst - uohmic,0.);
        ufc0 = lowLimit(-uact - ucon + unernst,0.);

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = ifc;
        stateVark[1] = ufc1;
        stateVark[2] = ifc0;
        stateVark[3] = ufc;
        stateVark[4] = pp1;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //FuelCellL1
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =ifc + (ufc - nstack*ufc1)/(nstack*Rohmic);
          systemEquations[1] =-((mTimestep*ufc0)/(mTimestep + 2*thaucon)) + \
ufc1 + delayedPart[2][1];
          systemEquations[2] =ifc0 - (ifc*mTimestep)/(mTimestep + 2*thaucon) \
+ delayedPart[3][1];
          systemEquations[3] =-cfc + ufc - ifc*Zcfc;
          systemEquations[4] =-cp1 + pp1 - dEp1*Zcp1;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = -(1/Rohmic);
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 1/(nstack*Rohmic);
          jacobianMatrix[0][4] = 0;
          jacobianMatrix[1][0] = 0;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[1][4] = 0;
          jacobianMatrix[2][0] = -(mTimestep/(mTimestep + 2*thaucon));
          jacobianMatrix[2][1] = 0;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[2][4] = 0;
          jacobianMatrix[3][0] = -Zcfc;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = 0;
          jacobianMatrix[4][3] = 0;
          jacobianMatrix[4][4] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          ifc=stateVark[0];
          ufc1=stateVark[1];
          ifc0=stateVark[2];
          ufc=stateVark[3];
          pp1=stateVark[4];
        //Expressions
        etaFC = ufc/(nstack*unernst);
        Powfc = ifc*ufc;
        WH2 = (ifc*MH2*nstack)/(2.*Faraday);
        qmp1 = -(ifc*MH2*nstack)/(2.*Faraday);
        dEp1 = cp*qmp1*Tp1;
        mFC = (A*Jmax*nstack*unernst)/kmFC;
        }

        //Calculate the delayed parts
        delayParts2[1] = (-(mTimestep*ufc0) + mTimestep*ufc1 - \
2*thaucon*ufc1)/(mTimestep + 2*thaucon);
        delayParts3[1] = (-(ifc*mTimestep) + ifc0*mTimestep - \
2*ifc0*thaucon)/(mTimestep + 2*thaucon);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];

        //Write new values to nodes
        //Port Pfc
        (*mpP_ufc)=ufc;
        (*mpP_ifc)=ifc;
        //Port Pp1
        (*mpP_pp1)=pp1;
        (*mpP_qmp1)=qmp1;
        (*mpP_dEp1)=dEp1;
        //outputVariables
        (*mpmFC)=mFC;
        (*mpunernst)=unernst;
        (*mpuohmic)=uohmic;
        (*mpuact)=uact;
        (*mpucon)=ucon;
        (*mpufc0)=ufc0;
        (*mpufcr)=ufcr;
        (*mpufc1)=ufc1;
        (*mpifc0)=ifc0;
        (*mpetaFC)=etaFC;
        (*mpPowfc)=Powfc;
        (*mprhoM)=rhoM;
        (*mpWH2)=WH2;

        //Update the delayed variabels
        mDelayedPart21.update(delayParts2[1]);
        mDelayedPart31.update(delayParts3[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // ELECTRICFUELCELLL1_HPP_INCLUDED

#ifndef ELECTRICFUELCELLL1_HPP_INCLUDED
#define ELECTRICFUELCELLL1_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file ElectricFuelCellL1.hpp
//! @author Petter Krus <petter.krus@liu.se>
//  co-author/auditor **Not yet audited by a second person**
//! @date Wed 30 Sep 2020 09:48:40
//! @brief Level 1 (conceptual with some dynamics) Fuel cell model
//! @ingroup ElectricComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, G:, Git, development-libraries, FuelCellLib}/ElectricFuelcellL1.nb*/

using namespace hopsan;

class ElectricFuelCellL1 : public ComponentQ
{
private:
     double R;
     double F;
     double nel;
     double T;
     double Tref;
     double CA;
     double A;
     double l;
     double dG;
     double dS;
     double P0;
     double Ph2;
     double Po2;
     double Ch2;
     double B;
     double Rc;
     double ksi1;
     double ksi3;
     double ksi4;
     double psi;
     double Jmax;
     double Jn;
     double Imax;
     double timeComp;
     double e;
     Port *mpPel1;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[4];
     int mNstep;
     //Port Pel1 variable
     double uel1;
     double iel1;
     double cel1;
     double Zcel1;
//==This code has been autogenerated using Compgen==
     //inputVariables
     //outputVariables
     double iFC0;
     double uA;
     double Pel;
     double Pin;
     //LocalExpressions variables
     double ksi2;
     double rhoM;
     double Co2;
     double unernst;
     double uA0;
     double conA0;
     double conA;
     double conOhm;
     //Expressions variables
     //Port Pel1 pointer
     double *mpP_uel1;
     double *mpP_iel1;
     double *mpP_cel1;
     double *mpP_Zcel1;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     //inputParameters pointers
     double *mpR;
     double *mpF;
     double *mpnel;
     double *mpT;
     double *mpTref;
     double *mpCA;
     double *mpA;
     double *mpl;
     double *mpdG;
     double *mpdS;
     double *mpP0;
     double *mpPh2;
     double *mpPo2;
     double *mpCh2;
     double *mpB;
     double *mpRc;
     double *mpksi1;
     double *mpksi3;
     double *mpksi4;
     double *mppsi;
     double *mpJmax;
     double *mpJn;
     double *mpImax;
     double *mptimeComp;
     double *mpe;
     //outputVariables pointers
     double *mpiFC0;
     double *mpuA;
     double *mpPel;
     double *mpPin;
     Delay mDelayedPart10;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new ElectricFuelCellL1();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(4,4);
        systemEquations.create(4);
        delayedPart.create(5,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpPel1=addPowerPort("Pel1","NodeElectric");
        //Add inputVariables to the component

        //Add inputParammeters to the component
            addInputVariable("R", "Gas constant", "J/(K mol)", 8.314,&mpR);
            addInputVariable("F", "Faradays constant", "", 96485.33212,&mpF);
            addInputVariable("nel", "", "", 1,&mpnel);
            addInputVariable("T", "", "K", 323,&mpT);
            addInputVariable("Tref", "", "K", 298.15,&mpTref);
            addInputVariable("CA", "Fuel cell capacitance", "A s/V", \
50.,&mpCA);
            addInputVariable("A", "", "m2", 0.00506,&mpA);
            addInputVariable("l", "", "m", 0.000178,&mpl);
            addInputVariable("dG", "", "", 228000.6,&mpdG);
            addInputVariable("dS", "Entropy rate", "J/(Ks)", 0.00085,&mpdS);
            addInputVariable("P0", "", "atm", 1,&mpP0);
            addInputVariable("Ph2", "", "atm", 1.476,&mpPh2);
            addInputVariable("Po2", "", "atm", 1.,&mpPo2);
            addInputVariable("Ch2", "", "atm", 1.,&mpCh2);
            addInputVariable("B", "", "V", 0.016,&mpB);
            addInputVariable("Rc", "", "", 0.0003,&mpRc);
            addInputVariable("ksi1", "", "", -0.948,&mpksi1);
            addInputVariable("ksi3", "", "", 0.000076,&mpksi3);
            addInputVariable("ksi4", "", "", -0.000193,&mpksi4);
            addInputVariable("psi", "", "", 23,&mppsi);
            addInputVariable("Jmax", "", "A/m2", 15000,&mpJmax);
            addInputVariable("Jn", "", "A/m2", 11.999999999999998,&mpJn);
            addInputVariable("Imax", "", "A", 42,&mpImax);
            addInputVariable("timeComp", "time compression factor.", "", \
1.,&mptimeComp);
            addInputVariable("e", "e", "", 2.71828,&mpe);
        //Add outputVariables to the component
            addOutputVariable("iFC0","Intermediate current","A",0.,&mpiFC0);
            addOutputVariable("uA","Intermediate voltage","V",0.,&mpuA);
            addOutputVariable("Pel","Output power","W",0.,&mpPel);
            addOutputVariable("Pin","Input power","W",0.,&mpPin);

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,4);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pel1
        mpP_uel1=getSafeNodeDataPtr(mpPel1, NodeElectric::Voltage);
        mpP_iel1=getSafeNodeDataPtr(mpPel1, NodeElectric::Current);
        mpP_cel1=getSafeNodeDataPtr(mpPel1, NodeElectric::WaveVariable);
        mpP_Zcel1=getSafeNodeDataPtr(mpPel1, NodeElectric::CharImpedance);

        //Read variables from nodes
        //Port Pel1
        uel1 = (*mpP_uel1);
        iel1 = (*mpP_iel1);
        cel1 = (*mpP_cel1);
        Zcel1 = (*mpP_Zcel1);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        R = (*mpR);
        F = (*mpF);
        nel = (*mpnel);
        T = (*mpT);
        Tref = (*mpTref);
        CA = (*mpCA);
        A = (*mpA);
        l = (*mpl);
        dG = (*mpdG);
        dS = (*mpdS);
        P0 = (*mpP0);
        Ph2 = (*mpPh2);
        Po2 = (*mpPo2);
        Ch2 = (*mpCh2);
        B = (*mpB);
        Rc = (*mpRc);
        ksi1 = (*mpksi1);
        ksi3 = (*mpksi3);
        ksi4 = (*mpksi4);
        psi = (*mppsi);
        Jmax = (*mpJmax);
        Jn = (*mpJn);
        Imax = (*mpImax);
        timeComp = (*mptimeComp);
        e = (*mpe);

        //Read outputVariables from nodes
        iFC0 = (*mpiFC0);
        uA = (*mpuA);
        Pel = (*mpPel);
        Pin = (*mpPin);

//==This code has been autogenerated using Compgen==

        //LocalExpressions
        ksi2 = 0.00286 + 0.0002*log(10000*A) + 0.000043*log(Ch2);
        rhoM = (1.816*(1 + (3.e-6*iFC0)/A + \
6.753150562581012e-17*Power(iFC0/A,2.5)*Power(T,2)))/(-0.634 - \
(3*Power(e,(4.18*(-303 + T))/T)*iFC0)/(10000.*A) + psi);
        Co2 = 1.968503937007874e-7*Power(e,498/T)*Po2;
        unernst = dG/(2.*F) + (dS*(T - Tref))/(2.*F) + \
(R*T*log((Ph2*Sqrt(Po2))/P0))/(2.*F);
        unernst = dG/(2.*F);
        uA0 = -ksi1 - ksi2*T - ksi4*T*log(iFC0) - B*log(1 - iel1/(A*Jmax)) - \
ksi3*T*log(1.968e-7*Power(e,498/T)*Po2);
        conA0 = iFC0/(1.e-6 + uA0*onPositive(uA0));
        conA = conA0*onPositive(conA0);
        conOhm = (l*rhoM)/A;

        //Initialize delays
        delayParts2[1] = (iel1*mTimestep - iFC0*mTimestep - 2*CA*uA)/(2.*CA);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];

        simulateOneTimestep();

     }
    void simulateOneTimestep()
     {
        Vec stateVar(4);
        Vec stateVark(4);
        Vec deltaStateVar(4);

        //Read variables from nodes
        //Port Pel1
        cel1 = (*mpP_cel1);
        Zcel1 = (*mpP_Zcel1);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        R = (*mpR);
        F = (*mpF);
        nel = (*mpnel);
        T = (*mpT);
        Tref = (*mpTref);
        CA = (*mpCA);
        A = (*mpA);
        l = (*mpl);
        dG = (*mpdG);
        dS = (*mpdS);
        P0 = (*mpP0);
        Ph2 = (*mpPh2);
        Po2 = (*mpPo2);
        Ch2 = (*mpCh2);
        B = (*mpB);
        Rc = (*mpRc);
        ksi1 = (*mpksi1);
        ksi3 = (*mpksi3);
        ksi4 = (*mpksi4);
        psi = (*mppsi);
        Jmax = (*mpJmax);
        Jn = (*mpJn);
        Imax = (*mpImax);
        timeComp = (*mptimeComp);
        e = (*mpe);

        //LocalExpressions
        ksi2 = 0.00286 + 0.0002*log(10000*A) + 0.000043*log(Ch2);
        rhoM = (1.816*(1 + (3.e-6*iFC0)/A + \
6.753150562581012e-17*Power(iFC0/A,2.5)*Power(T,2)))/(-0.634 - \
(3*Power(e,(4.18*(-303 + T))/T)*iFC0)/(10000.*A) + psi);
        Co2 = 1.968503937007874e-7*Power(e,498/T)*Po2;
        unernst = dG/(2.*F) + (dS*(T - Tref))/(2.*F) + \
(R*T*log((Ph2*Sqrt(Po2))/P0))/(2.*F);
        unernst = dG/(2.*F);
        uA0 = -ksi1 - ksi2*T - ksi4*T*log(iFC0) - B*log(1 - iel1/(A*Jmax)) - \
ksi3*T*log(1.968e-7*Power(e,498/T)*Po2);
        conA0 = iFC0/(1.e-6 + uA0*onPositive(uA0));
        conA = conA0*onPositive(conA0);
        conOhm = (l*rhoM)/A;

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = iFC0;
        stateVark[1] = uA;
        stateVark[2] = iel1;
        stateVark[3] = uel1;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //FuelCellL1
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =iFC0 + conOhm*(uA - unernst);
          systemEquations[1] =((iel1 - iFC0)*mTimestep)/(2.*CA) + uA + \
delayedPart[2][1];
          systemEquations[2] =iel1 + conA*(-uA + uel1);
          systemEquations[3] =-cel1 + uel1 - iel1*Zcel1;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = conOhm;
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[1][0] = -mTimestep/(2.*CA);
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = mTimestep/(2.*CA);
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[2][0] = 0;
          jacobianMatrix[2][1] = -conA;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = conA;
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = -Zcel1;
          jacobianMatrix[3][3] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          iFC0=stateVark[0];
          uA=stateVark[1];
          iel1=stateVark[2];
          uel1=stateVark[3];
        //Expressions
        Pel = iel1*uel1;
        Pin = iFC0*unernst;
        }

        //Calculate the delayed parts
        delayParts2[1] = (iel1*mTimestep - iFC0*mTimestep - 2*CA*uA)/(2.*CA);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];

        //Write new values to nodes
        //Port Pel1
        (*mpP_uel1)=uel1;
        (*mpP_iel1)=iel1;
        //outputVariables
        (*mpiFC0)=iFC0;
        (*mpuA)=uA;
        (*mpPel)=Pel;
        (*mpPin)=Pin;

        //Update the delayed variabels
        mDelayedPart21.update(delayParts2[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // ELECTRICFUELCELLL1_HPP_INCLUDED

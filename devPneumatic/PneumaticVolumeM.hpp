#ifndef PNEUMATICVOLUMEM_HPP_INCLUDED
#define PNEUMATICVOLUMEM_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file PneumaticVolumeM.hpp
//! @author Petter Krus <petter.krus@liu.se>
//  co-author/auditor **Not yet audited by a second person**
//! @date Tue 11 Aug 2020 11:21:36
//! @brief Pressure source
//! @ingroup PneumaticComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, Users, petkr14, Dropbox, HopsanComponents, PneumaticDevelop, \
PneumaticComponents}/PneumaticVolumeM.nb*/

using namespace hopsan;

   class PneumaticVolumeM : public ComponentC
    {

    private:
        double mPh;
		double V,R,cv,ka,T0,alpha,pmin,mass,fak,Tav,pav,ZcE;
        Port *mpP1;
        size_t mNumPorts;
        std::vector<double*> mvpP1_p, mvpP1_qm, mvpP1_T, mvpP1_dE, mvpP1_c, mvpP1_Zc;
        double  *mpV, *mpR, *mpcv, *mpka, *mpT0,*mpalpha,*mppmin,*mpmass;

        std::vector<double> mvCnew;
        std::vector<double> mvC0;

    public:
        static Component *Creator()
        {
            return new PneumaticVolumeM();
        }

        void configure()
        {
        //Add ports to the component
            mpP1 = addPowerMultiPort("P1", "NodePneumatic");

            addConstant("P_high", "High pressure (for animation)", "Pa", 2.e6, mPh);
 
		//Add inputParammeters to the component
            addInputVariable("V", "Volume", "m3", 0.0001,&mpV);
            addInputVariable("R", "Gas constant", "J/Kg K", 287.,&mpR);
            addInputVariable("cv", "heatcoeff", "J/Kg K", 718.,&mpcv);
            addInputVariable("ka", "heat conductance", "J/Ks", 0.,&mpka);
            addInputVariable("T0", "Outside temperature", "K", 300.,&mpT0);
            addInputVariable("alpha", "numerical damping", "", 0.1,&mpalpha);
            addInputVariable("pmin", "numerical min pressure", "",1.,&mppmin);
			
			setDefaultStartValue(mpP1, NodePneumatic::MASSFLOW, 0.0);
            setDefaultStartValue(mpP1, NodePneumatic::PRESSURE, 1.0e5);
            setDefaultStartValue(mpP1, NodePneumatic::ENERGYFLOW, 0.0);
			
        //Add outputVariables to the component
            addOutputVariable("mass","Mass in volume","kg",0.001,&mpmass);

        }


        void initialize()
        {
//            double V,R,cv,ka,T0,alpha,pmin,mass,fak,Tav,pav,ZcE;
         //Read inputParameters from nodes
			V = (*mpV);
			R = (*mpR);
			cv = (*mpcv);
			ka = (*mpka);
			T0 = (*mpT0);
			alpha = (*mpalpha);
			pmin = (*mppmin);
        //Read outputVariables from nodes
			mass = (*mpmass);

            mNumPorts = mpP1->getNumPorts();
            mvpP1_p.resize(mNumPorts);
            mvpP1_qm.resize(mNumPorts);
            mvpP1_T.resize(mNumPorts);
            mvpP1_dE.resize(mNumPorts);
            mvpP1_c.resize(mNumPorts);
            mvpP1_Zc.resize(mNumPorts);
            mvC0.resize(mNumPorts);
            mvCnew.resize(mNumPorts);

        //InitialExpressions
//            ZcE = double(mNumPorts)*betae/(2.0*V)*mTimestep/(1.0-alpha);
			ZcE = mNumPorts*(fak*mTimestep*R)/((cv + R)*2*V);
			
            for (size_t i=0; i<mNumPorts; ++i)
            {
				mvpP1_p[i]  = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::PRESSURE, 0.0);
                mvpP1_qm[i]  = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::MASSFLOW, 0.0);
                mvpP1_dE[i]  = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::ENERGYFLOW, 0.0);
                mvpP1_c[i]  = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::WAVEVARIABLE, 0.0);
                mvpP1_T[i] = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::TEMPERATURE, 0.0);
                mvpP1_Zc[i] = getSafeMultiPortNodeDataPtr(mpP1, i, NodePneumatic::CHARIMP, 0.0);

                *mvpP1_p[i]  = getDefaultStartValue(mpP1, NodePneumatic::PRESSURE, i);
                *mvpP1_qm[i]  = getDefaultStartValue(mpP1, NodePneumatic::MASSFLOW, i);
                *mvpP1_dE[i]  = getDefaultStartValue(mpP1, NodePneumatic::ENERGYFLOW, i);
                *mvpP1_c[i]  = getDefaultStartValue(mpP1, NodePneumatic::WAVEVARIABLE, i);
                *mvpP1_T[i]  = getDefaultStartValue(mpP1, NodePneumatic::TEMPERATURE, i);
                *mvpP1_Zc[i]  = getDefaultStartValue(mpP1, NodePneumatic::CHARIMP, i);
//                pTot       += getDefaultStartValue(mpP1,NodePneumatic::Pressure, i)+ZcE*getDefaultStartValue(mpP1,NodePneumatic::Energyflow, i);
                *mvpP1_Zc[i] = ZcE;
            }

            for (size_t i=0; i<mNumPorts; ++i)
            {
                *mvpP1_c[i] = (*mvpP1_p[0]);
            }
			//InitialExpressions
			fak = 1/(1 - alpha);
			Tav = *mvpP1_T[0];
			pav = *mvpP1_p[0];
			mass = (pav*V)/(R*Tav);
        }


        void simulateOneTimestep()
        {
            double cTot = 0.0;
            R = (*mpR);
            cv = (*mpcv);
            alpha = (*mpalpha);
            V = (*mpV);
            fak = 1/(1 - alpha);

	
 //           Zc = double(mNumPorts)*betae/(2.0*V)*mTimestep/(1.0-alpha);
			ZcE = mNumPorts*(fak*mTimestep*R)/((cv + R)*2*V);

            //Equations
            for (size_t i=0; i<mNumPorts; ++i)
            {
                cTot += (*mvpP1_c[i]) + 2.0*ZcE*(*mvpP1_dE[i]);
				mass += (*mvpP1_qm[i])*mTimestep;
            }
            pav = 2*cTot/mNumPorts+4*ZcE*ka*(T0 - Tav)/mNumPorts;
			Tav=pav*V/(mass*R);

            for (size_t i=0; i<mNumPorts; ++i)
            {
                mvC0[i] = pav-(*mvpP1_c[i]) - 2.0*ZcE*(*mvpP1_dE[i]);
                mvCnew[i] = alpha*(*mvpP1_c[i]) + (1.0-alpha)*mvC0[i];
            }

            //Write new values
            for(size_t i=0; i<mNumPorts; ++i)
            {
                (*mvpP1_Zc[i]) = ZcE;
                (*mvpP1_c[i]) = mvCnew[i];
				(*mvpP1_T[i]) = Tav;
            }        
			//outputVariables
			(*mpmass)=mass;

        }


        void finalize()
        {
        }
    };
#endif // PNEUMATICVOLUMEM_HPP_INCLUDED

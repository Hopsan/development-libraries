#ifndef PNEUMATICPISTONSPRINGMASS_HPP_INCLUDED
#define PNEUMATICPISTONSPRINGMASS_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file PneumaticPistonSpringMass.hpp
//! @author Petter Krus <petter.krus@liu.se>
//  co-author/auditor **Not yet audited by a second person**
//! @date Thu 6 Aug 2020 18:20:10
//! @brief Pneumatic piston with spring return
//! @ingroup PneumaticComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, H:, PettersDropbox, Dropbox, HopsanComponents, PneumaticDevelop, \
PneumaticComponents}/PneumaticPistonSpringMass.nb*/

using namespace hopsan;

class PneumaticPistonSpringMass : public ComponentQ
{
private:
     double A1;
     double A2;
     double SL;
     double Cip;
     double bp;
     double ks;
     double f0;
     double fc;
     double bfc;
     double xmin;
     double xmax;
     double mL;
     double bL;
     double patm;
     double Tatm;
     double R;
     double cv;
     Port *mpP1;
     Port *mpP2;
     Port *mpPL;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     double delayParts8[9];
     double delayParts9[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[9];
     int mNstep;
     //Port P1 variable
     double p1;
     double qm1;
     double T1;
     double dE1;
     double c1;
     double Zc1;
     //Port P2 variable
     double p2;
     double qm2;
     double T2;
     double dE2;
     double c2;
     double Zc2;
     //Port PL variable
     double fL;
     double xL;
     double vL;
     double cL;
     double ZcL;
     double eqMassL;
//==This code has been autogenerated using Compgen==
     //inputVariables
     //outputVariables
     //Port P1 pointer
     double *mpP_p1;
     double *mpP_qm1;
     double *mpP_T1;
     double *mpP_dE1;
     double *mpP_c1;
     double *mpP_Zc1;
     //Port P2 pointer
     double *mpP_p2;
     double *mpP_qm2;
     double *mpP_T2;
     double *mpP_dE2;
     double *mpP_c2;
     double *mpP_Zc2;
     //Port PL pointer
     double *mpP_fL;
     double *mpP_xL;
     double *mpP_vL;
     double *mpP_cL;
     double *mpP_ZcL;
     double *mpP_eqMassL;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     //inputParameters pointers
     double *mpA1;
     double *mpA2;
     double *mpSL;
     double *mpCip;
     double *mpbp;
     double *mpks;
     double *mpf0;
     double *mpfc;
     double *mpbfc;
     double *mpxmin;
     double *mpxmax;
     double *mpmL;
     double *mpbL;
     double *mppatm;
     double *mpTatm;
     double *mpR;
     double *mpcv;
     //outputVariables pointers
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart40;
     Delay mDelayedPart50;
     Delay mDelayedPart60;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new PneumaticPistonSpringMass();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(9,9);
        systemEquations.create(9);
        delayedPart.create(10,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpP1=addPowerPort("P1","NodePneumatic");
        mpP2=addPowerPort("P2","NodePneumatic");
        mpPL=addPowerPort("PL","NodeMechanic");
        //Add inputVariables to the component

        //Add inputParammeters to the component
            addInputVariable("A1", "Piston area 1", "m2", 0.001,&mpA1);
            addInputVariable("A2", "Piston area 2", "m2", 0.001,&mpA2);
            addInputVariable("SL", "Stroke", "m", 0.5,&mpSL);
            addInputVariable("Cip", "Leak coeff.", "m3/(s Pa)", 0.,&mpCip);
            addInputVariable("bp", "Visc. friction coeff.", "N/m/s", \
30.,&mpbp);
            addInputVariable("ks", "Spring constant", "N/m", 100.,&mpks);
            addInputVariable("f0", "Spring pre-load", "N", 100.,&mpf0);
            addInputVariable("fc", "Dry friction (+/-)", "N", 30.,&mpfc);
            addInputVariable("bfc", "Numerical friction factor.", "", \
1.,&mpbfc);
            addInputVariable("xmin", "Limitation on stroke", "m", \
0.,&mpxmin);
            addInputVariable("xmax", "Limitation on stroke", "m", \
0.5,&mpxmax);
            addInputVariable("mL", "Inertia", "kg", 100.,&mpmL);
            addInputVariable("bL", "Viscous friction coefficient of load", \
"Ns/m", 0.,&mpbL);
            addInputVariable("patm", "Ambient pressure", "Pa", \
100000.,&mppatm);
            addInputVariable("Tatm", "Ambient temperature", "K", \
297.,&mpTatm);
            addInputVariable("R", "Gas constant", "J/Kg K", 287.,&mpR);
            addInputVariable("cv", "heatcoeff", "J/Kg K", 718,&mpcv);
        //Add outputVariables to the component

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,9);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port P1
        mpP_p1=getSafeNodeDataPtr(mpP1, NodePneumatic::Pressure);
        mpP_qm1=getSafeNodeDataPtr(mpP1, NodePneumatic::MassFlow);
        mpP_T1=getSafeNodeDataPtr(mpP1, NodePneumatic::Temperature);
        mpP_dE1=getSafeNodeDataPtr(mpP1, NodePneumatic::EnergyFlow);
        mpP_c1=getSafeNodeDataPtr(mpP1, NodePneumatic::WaveVariable);
        mpP_Zc1=getSafeNodeDataPtr(mpP1, NodePneumatic::CharImpedance);
        //Port P2
        mpP_p2=getSafeNodeDataPtr(mpP2, NodePneumatic::Pressure);
        mpP_qm2=getSafeNodeDataPtr(mpP2, NodePneumatic::MassFlow);
        mpP_T2=getSafeNodeDataPtr(mpP2, NodePneumatic::Temperature);
        mpP_dE2=getSafeNodeDataPtr(mpP2, NodePneumatic::EnergyFlow);
        mpP_c2=getSafeNodeDataPtr(mpP2, NodePneumatic::WaveVariable);
        mpP_Zc2=getSafeNodeDataPtr(mpP2, NodePneumatic::CharImpedance);
        //Port PL
        mpP_fL=getSafeNodeDataPtr(mpPL, NodeMechanic::Force);
        mpP_xL=getSafeNodeDataPtr(mpPL, NodeMechanic::Position);
        mpP_vL=getSafeNodeDataPtr(mpPL, NodeMechanic::Velocity);
        mpP_cL=getSafeNodeDataPtr(mpPL, NodeMechanic::WaveVariable);
        mpP_ZcL=getSafeNodeDataPtr(mpPL, NodeMechanic::CharImpedance);
        mpP_eqMassL=getSafeNodeDataPtr(mpPL, NodeMechanic::EquivalentMass);

        //Read variables from nodes
        //Port P1
        p1 = (*mpP_p1);
        qm1 = (*mpP_qm1);
        T1 = (*mpP_T1);
        dE1 = (*mpP_dE1);
        c1 = (*mpP_c1);
        Zc1 = (*mpP_Zc1);
        //Port P2
        p2 = (*mpP_p2);
        qm2 = (*mpP_qm2);
        T2 = (*mpP_T2);
        dE2 = (*mpP_dE2);
        c2 = (*mpP_c2);
        Zc2 = (*mpP_Zc2);
        //Port PL
        fL = (*mpP_fL);
        xL = (*mpP_xL);
        vL = (*mpP_vL);
        cL = (*mpP_cL);
        ZcL = (*mpP_ZcL);
        eqMassL = (*mpP_eqMassL);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        A1 = (*mpA1);
        A2 = (*mpA2);
        SL = (*mpSL);
        Cip = (*mpCip);
        bp = (*mpbp);
        ks = (*mpks);
        f0 = (*mpf0);
        fc = (*mpfc);
        bfc = (*mpbfc);
        xmin = (*mpxmin);
        xmax = (*mpxmax);
        mL = (*mpmL);
        bL = (*mpbL);
        patm = (*mppatm);
        Tatm = (*mpTatm);
        R = (*mpR);
        cv = (*mpcv);

        //Read outputVariables from nodes

//==This code has been autogenerated using Compgen==


        //Initialize delays
        delayParts1[1] = (-(A1*c1*mTimestep) + A2*c2*mTimestep + cL*mTimestep \
+ f0*mTimestep + A1*mTimestep*patm - A2*mTimestep*patm - 2*mL*vL + \
bL*mTimestep*vL + bp*mTimestep*vL + ks*mTimestep*xL - A1*mTimestep*qm1*Zc1 + \
A2*mTimestep*qm2*Zc2 + mTimestep*vL*ZcL + \
mTimestep*limit((bfc*mL*vL)/mTimestep,-fc,fc))/(2*mL + bL*mTimestep + \
bp*mTimestep + mTimestep*ZcL);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-(mTimestep*vL) - 2*xL)/2.;
        mDelayedPart21.initialize(mNstep,delayParts2[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];

        simulateOneTimestep();

     }
    void simulateOneTimestep()
     {
        Vec stateVar(9);
        Vec stateVark(9);
        Vec deltaStateVar(9);

        //Read variables from nodes
        //Port P1
        T1 = (*mpP_T1);
        c1 = (*mpP_c1);
        Zc1 = (*mpP_Zc1);
        //Port P2
        T2 = (*mpP_T2);
        c2 = (*mpP_c2);
        Zc2 = (*mpP_Zc2);
        //Port PL
        cL = (*mpP_cL);
        ZcL = (*mpP_ZcL);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        A1 = (*mpA1);
        A2 = (*mpA2);
        SL = (*mpSL);
        Cip = (*mpCip);
        bp = (*mpbp);
        ks = (*mpks);
        f0 = (*mpf0);
        fc = (*mpfc);
        bfc = (*mpbfc);
        xmin = (*mpxmin);
        xmax = (*mpxmax);
        mL = (*mpmL);
        bL = (*mpbL);
        patm = (*mppatm);
        Tatm = (*mpTatm);
        R = (*mpR);
        cv = (*mpcv);

        //LocalExpressions

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = vL;
        stateVark[1] = xL;
        stateVark[2] = qm1;
        stateVark[3] = qm2;
        stateVark[4] = dE1;
        stateVark[5] = dE2;
        stateVark[6] = p1;
        stateVark[7] = p2;
        stateVark[8] = fL;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //PistonSpringMass
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =vL - dxLimit(limit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax),xmin,xmax)*(-((mTimestep*(A2*c2 + cL + f0 - \
A2*patm + ks*xL - A1*(c1 - patm + qm1*Zc1) + A2*qm2*Zc2 + \
limit((bfc*mL*vL)/mTimestep,-fc,fc)))/(2*mL + mTimestep*(bL + bp + ZcL))) - \
delayedPart[1][1]);
          systemEquations[1] =xL - limit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax);
          systemEquations[2] =qm1 + (Cip*R*(patm*(-1. - 1.*T1) + p1*(1. + \
T1)) + A1*p1*vL)/(R*(1. + T1));
          systemEquations[3] =qm2 + (Cip*R*(p1*(-1. - 1.*T2) + p2*(1. + \
1.*T2)) - 1.*A2*p2*vL)/(R*(1. + T2));
          systemEquations[4] =dE1 - qm1*(cv + R)*T1;
          systemEquations[5] =dE2 - qm2*(cv + R)*T2;
          systemEquations[6] =-c1 + p1 - dE1*Zc1;
          systemEquations[7] =-c2 + p2 - dE2*Zc2;
          systemEquations[8] =-cL + fL - vL*ZcL;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1 + \
(bfc*mL*dxLimit((bfc*mL*vL)/mTimestep,-fc,fc)*dxLimit(limit((mTimestep*vL)/2. \
- delayedPart[2][1],xmin,xmax),xmin,xmax))/(2*mL + mTimestep*(bL + bp + \
ZcL));
          jacobianMatrix[0][1] = \
(ks*mTimestep*dxLimit(limit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax),xmin,xmax))/(2*mL + mTimestep*(bL + bp + ZcL));
          jacobianMatrix[0][2] = \
-((A1*mTimestep*Zc1*dxLimit(limit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax),xmin,xmax))/(2*mL + mTimestep*(bL + bp + ZcL)));
          jacobianMatrix[0][3] = \
(A2*mTimestep*Zc2*dxLimit(limit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax),xmin,xmax))/(2*mL + mTimestep*(bL + bp + ZcL));
          jacobianMatrix[0][4] = 0;
          jacobianMatrix[0][5] = 0;
          jacobianMatrix[0][6] = 0;
          jacobianMatrix[0][7] = 0;
          jacobianMatrix[0][8] = 0;
          jacobianMatrix[1][0] = -(mTimestep*dxLimit((mTimestep*vL)/2. - \
delayedPart[2][1],xmin,xmax))/2.;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[1][4] = 0;
          jacobianMatrix[1][5] = 0;
          jacobianMatrix[1][6] = 0;
          jacobianMatrix[1][7] = 0;
          jacobianMatrix[1][8] = 0;
          jacobianMatrix[2][0] = (A1*p1)/(R*(1. + T1));
          jacobianMatrix[2][1] = 0;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[2][4] = 0;
          jacobianMatrix[2][5] = 0;
          jacobianMatrix[2][6] = (Cip*R*(1. + T1) + A1*vL)/(R*(1. + T1));
          jacobianMatrix[2][7] = 0;
          jacobianMatrix[2][8] = 0;
          jacobianMatrix[3][0] = (-1.*A2*p2)/(R*(1. + T2));
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = 0;
          jacobianMatrix[3][5] = 0;
          jacobianMatrix[3][6] = (Cip*(-1. - 1.*T2))/(1. + T2);
          jacobianMatrix[3][7] = (Cip*R*(1. + 1.*T2) - 1.*A2*vL)/(R*(1. + \
T2));
          jacobianMatrix[3][8] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = -((cv + R)*T1);
          jacobianMatrix[4][3] = 0;
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = 0;
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[4][7] = 0;
          jacobianMatrix[4][8] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = -((cv + R)*T2);
          jacobianMatrix[5][4] = 0;
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[5][7] = 0;
          jacobianMatrix[5][8] = 0;
          jacobianMatrix[6][0] = 0;
          jacobianMatrix[6][1] = 0;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = 0;
          jacobianMatrix[6][4] = -Zc1;
          jacobianMatrix[6][5] = 0;
          jacobianMatrix[6][6] = 1;
          jacobianMatrix[6][7] = 0;
          jacobianMatrix[6][8] = 0;
          jacobianMatrix[7][0] = 0;
          jacobianMatrix[7][1] = 0;
          jacobianMatrix[7][2] = 0;
          jacobianMatrix[7][3] = 0;
          jacobianMatrix[7][4] = 0;
          jacobianMatrix[7][5] = -Zc2;
          jacobianMatrix[7][6] = 0;
          jacobianMatrix[7][7] = 1;
          jacobianMatrix[7][8] = 0;
          jacobianMatrix[8][0] = -ZcL;
          jacobianMatrix[8][1] = 0;
          jacobianMatrix[8][2] = 0;
          jacobianMatrix[8][3] = 0;
          jacobianMatrix[8][4] = 0;
          jacobianMatrix[8][5] = 0;
          jacobianMatrix[8][6] = 0;
          jacobianMatrix[8][7] = 0;
          jacobianMatrix[8][8] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          vL=stateVark[0];
          xL=stateVark[1];
          qm1=stateVark[2];
          qm2=stateVark[3];
          dE1=stateVark[4];
          dE2=stateVark[5];
          p1=stateVark[6];
          p2=stateVark[7];
          fL=stateVark[8];
        }

        //Calculate the delayed parts
        delayParts1[1] = (-(A1*c1*mTimestep) + A2*c2*mTimestep + cL*mTimestep \
+ f0*mTimestep + A1*mTimestep*patm - A2*mTimestep*patm - 2*mL*vL + \
bL*mTimestep*vL + bp*mTimestep*vL + ks*mTimestep*xL - A1*mTimestep*qm1*Zc1 + \
A2*mTimestep*qm2*Zc2 + mTimestep*vL*ZcL + \
mTimestep*limit((bfc*mL*vL)/mTimestep,-fc,fc))/(2*mL + bL*mTimestep + \
bp*mTimestep + mTimestep*ZcL);
        delayParts2[1] = (-(mTimestep*vL) - 2*xL)/2.;

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];

        //Write new values to nodes
        //Port P1
        (*mpP_p1)=p1;
        (*mpP_qm1)=qm1;
        (*mpP_dE1)=dE1;
        //Port P2
        (*mpP_p2)=p2;
        (*mpP_qm2)=qm2;
        (*mpP_dE2)=dE2;
        //Port PL
        (*mpP_fL)=fL;
        (*mpP_xL)=xL;
        (*mpP_vL)=vL;
        (*mpP_eqMassL)=eqMassL;
        //outputVariables

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // PNEUMATICPISTONSPRINGMASS_HPP_INCLUDED

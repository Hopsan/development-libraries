#ifndef PNEUMATICVOLUME2_HPP_INCLUDED
#define PNEUMATICVOLUME2_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file PneumaticVolume2.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Wed 13 Mar 2013 15:36:17
//! @brief Pneumatic volume
//! @ingroup PneumaticComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, Users, petkr14.IEI, Documents, CompgenNG}/PneumaticNGM.nb*/

using namespace hopsan;

class PneumaticVolume2 : public ComponentC
{
private:
     double mV;
     double mR;
     double mcv;
     double mka;
     double mT0;
     double malpha;
     double mpmin;
     Port *mpPp1;
     Port *mpPp2;
     Port *mpPmass;
     double delayParts1[9];
     double delayParts2[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[1];
     int mNstep;
     //Port Pp1 variable
     double pp1;
     double qmp1;
     double Tp1;
     double dEp1;
     double cp1;
     double Zcp1;
     //Port Pp2 variable
     double pp2;
     double qmp2;
     double Tp2;
     double dEp2;
     double cp2;
     double Zcp2;
//==This code has been autogenerated using Compgen==
     //inputVariables
     //outputVariables
     double mass;
     //InitialExpressions variables
     double fak;
     double Tav;
     double pav;

     //LocalExpressions variables
     double ZcEP;
     double cdp1;
     double cdp2;
     //Expressions variables
     //Port Pp1 pointer
     double *mpND_pp1;
     double *mpND_qmp1;
     double *mpND_Tp1;
     double *mpND_dEp1;
     double *mpND_cp1;
     double *mpND_Zcp1;
     //Port Pp2 pointer
     double *mpND_pp2;
     double *mpND_qmp2;
     double *mpND_Tp2;
     double *mpND_dEp2;
     double *mpND_cp2;
     double *mpND_Zcp2;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     //outputVariables pointers
     double *mpND_mass;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new PneumaticVolume2();
     }

     void configure()
     {
        const double V = 0.001;
        const double R = 287.;
        const double cv = 718.;
        const double ka = 0.;
        const double T0 = 300.;
        const double alpha = 0.1;
        const double pmin = 1.;
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(1,1);
        systemEquations.create(1);
        delayedPart.create(2,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;

        mV = V;
        mR = R;
        mcv = cv;
        mka = ka;
        mT0 = T0;
        malpha = alpha;
        mpmin = pmin;

        //Add ports to the component
        mpPp1=addPowerPort("Pp1","NodePneumatic");
        mpPp2=addPowerPort("Pp2","NodePneumatic");

        //Add inputVariables ports to the component

        //Add outputVariables ports to the component
        mpPmass=addWritePort("Pmass","NodeSignal", Port::NOTREQUIRED);

//==This code has been autogenerated using Compgen==
        //Register changable parameters to the HOPSAN++ core
        registerParameter("V", "Volume", "m3", mV);
        registerParameter("R", "Gas constant", "J/Kg K", mR);
        registerParameter("cv", "heatcoeff", "J/Kg K", mcv);
        registerParameter("ka", "heat conductance", "J/Ks", mka);
        registerParameter("T0", "Outside temperature", "K", mT0);
        registerParameter("alpha", "numerical damping", "", malpha);
        registerParameter("pmin", "numerical min pressure", "", mpmin);
        mpSolver = new EquationSystemSolver(this,1);
        //Set start values in nodes
        //Port Pp1
        setStartValue(mpPp1, NodePneumatic::PRESSURE,100000.);
        setStartValue(mpPp1, NodePneumatic::MASSFLOW,0.);
        setStartValue(mpPp1, NodePneumatic::TEMPERATURE,293.);
        setStartValue(mpPp1, NodePneumatic::ENERGYFLOW,0.);
        setStartValue(mpPp1, NodePneumatic::WAVEVARIABLE,0.);
        setStartValue(mpPp1, NodePneumatic::CHARIMP,0.);
        //Port Pp2
        setStartValue(mpPp2, NodePneumatic::PRESSURE,100000.);
        setStartValue(mpPp2, NodePneumatic::MASSFLOW,0.);
        setStartValue(mpPp2, NodePneumatic::TEMPERATURE,293.);
        setStartValue(mpPp2, NodePneumatic::ENERGYFLOW,0.);
        setStartValue(mpPp2, NodePneumatic::WAVEVARIABLE,0.);
        setStartValue(mpPp2, NodePneumatic::CHARIMP,0.);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pp1
        mpND_pp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::PRESSURE);
        mpND_qmp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::MASSFLOW);
        mpND_Tp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::TEMPERATURE);
        mpND_dEp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::ENERGYFLOW);
        mpND_cp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::WAVEVARIABLE);
        mpND_Zcp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::CHARIMP);
        //Port Pp2
        mpND_pp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::PRESSURE);
        mpND_qmp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::MASSFLOW);
        mpND_Tp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::TEMPERATURE);
        mpND_dEp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::ENERGYFLOW);
        mpND_cp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::WAVEVARIABLE);
        mpND_Zcp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::CHARIMP);
        //Read inputVariables pointers from nodes
        //Read outputVariable pointers from nodes
        mpND_mass=getSafeNodeDataPtr(mpPmass, NodeSignal::VALUE);

        //Read variables from nodes
        //Port Pp1
        pp1 = (*mpND_pp1);
        qmp1 = (*mpND_qmp1);
        Tp1 = (*mpND_Tp1);
        dEp1 = (*mpND_dEp1);
        cp1 = (*mpND_cp1);
        Zcp1 = (*mpND_Zcp1);
        //Port Pp2
        pp2 = (*mpND_pp2);
        qmp2 = (*mpND_qmp2);
        Tp2 = (*mpND_Tp2);
        dEp2 = (*mpND_dEp2);
        cp2 = (*mpND_cp2);
        Zcp2 = (*mpND_Zcp2);

        //Read inputVariables from nodes

        //Read outputVariables from nodes
        mass = mpPmass->getStartValue(NodeSignal::VALUE);

//==This code has been autogenerated using Compgen==
        //InitialExpressions
        fak = 1/(1 - malpha);
        Tav = (Tp1 + Tp2)/2.;
        pav = (pp1 + pp2)/2.;
        mass = (mV*pav)/(mR*Tav);

        //LocalExpressions
        pav = mpmin/2. + ((-mpmin + pp1 + pp2)*onPositive(-mpmin + pp1 + \
pp2))/2.;
        Tav = (mV*pav)/(mass*mR);
        ZcEP = (fak*mR*mTimestep)/((mcv + mR)*mV);
        cdp1 = cp2 + 2*(dEp2 + (mka*(mT0 - Tav))/2.)*ZcEP;
        cdp2 = cp1 + 2*(dEp1 + (mka*(mT0 - Tav))/2.)*ZcEP;

        //Initialize delays
        delayParts1[1] = (-2*mass - mTimestep*qmp1 - mTimestep*qmp2)/2.;
        mDelayedPart11.initialize(mNstep,delayParts1[1]);

        delayedPart[1][1] = delayParts1[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(1);
        Vec stateVark(1);
        Vec deltaStateVar(1);

        //Read variables from nodes
        //Port Pp1
        pp1 = (*mpND_pp1);
        qmp1 = (*mpND_qmp1);
        dEp1 = (*mpND_dEp1);
        //Port Pp2
        pp2 = (*mpND_pp2);
        qmp2 = (*mpND_qmp2);
        dEp2 = (*mpND_dEp2);

        //Read inputVariables from nodes

        //LocalExpressions
        pav = mpmin/2. + ((-mpmin + pp1 + pp2)*onPositive(-mpmin + pp1 + \
pp2))/2.;
        Tav = (mV*pav)/(mass*mR);
        ZcEP = (fak*mR*mTimestep)/((mcv + mR)*mV);
        cdp1 = cp2 + 2*(dEp2 + (mka*(mT0 - Tav))/2.)*ZcEP;
        cdp2 = cp1 + 2*(dEp1 + (mka*(mT0 - Tav))/2.)*ZcEP;

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = mass;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //Volume2
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =mass - (mTimestep*(qmp1 + qmp2))/2. + \
delayedPart[1][1];

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          mass=stateVark[0];
          //Expressions
          Tp1 = Tav;
          Tp2 = Tav;
          cp1 = cdp1 + (mka*(mT0 - Tav)*ZcEP)/2.;
          cp2 = cdp2 + (mka*(mT0 - Tav)*ZcEP)/2.;
          Zcp1 = ZcEP;
          Zcp2 = ZcEP;
        }

        //Calculate the delayed parts
        delayParts1[1] = (-2*mass - mTimestep*qmp1 - mTimestep*qmp2)/2.;

        delayedPart[1][1] = delayParts1[1];

        //Write new values to nodes
        //Port Pp1
        (*mpND_Tp1)=Tp1;
        (*mpND_cp1)=cp1;
        (*mpND_Zcp1)=Zcp1;
        //Port Pp2
        (*mpND_Tp2)=Tp2;
        (*mpND_cp2)=cp2;
        (*mpND_Zcp2)=Zcp2;
        //outputVariables
        (*mpND_mass)=mass;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);

     }
};
#endif // PNEUMATICVOLUME2_HPP_INCLUDED

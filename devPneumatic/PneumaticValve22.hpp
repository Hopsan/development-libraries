#ifndef PNEUMATICVALVE22_HPP_INCLUDED
#define PNEUMATICVALVE22_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file PneumaticValve22.hpp
//! @author Petter Krus <petter.krus@liu.se>
//  co-author/auditor **Not yet audited by a second person**
//! @date Wed 5 Aug 2020 15:50:43
//! @brief Pneumatic 22-valve
//! @ingroup PneumaticComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, H:, PettersDropbox, Dropbox, HopsanComponents, PneumaticDevelop, \
PneumaticComponents}/PneumaticValve22.nb*/

using namespace hopsan;

class PneumaticValve22 : public ComponentQ
{
private:
     double Bf;
     double Cf;
     double p0;
     double T0;
     double R;
     double cv;
     double eps;
     Port *mpP1;
     Port *mpP2;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[7];
     int mNstep;
     //Port P1 variable
     double p1;
     double qm1;
     double T1;
     double dE1;
     double c1;
     double Zc1;
     //Port P2 variable
     double p2;
     double qm2;
     double T2;
     double dE2;
     double c2;
     double Zc2;
//==This code has been autogenerated using Compgen==
     //inputVariables
     double xin;
     //outputVariables
     double qmP;
     double qmN;
     //LocalExpressions variables
     double cp;
     //Expressions variables
     //Port P1 pointer
     double *mpP_p1;
     double *mpP_qm1;
     double *mpP_T1;
     double *mpP_dE1;
     double *mpP_c1;
     double *mpP_Zc1;
     //Port P2 pointer
     double *mpP_p2;
     double *mpP_qm2;
     double *mpP_T2;
     double *mpP_dE2;
     double *mpP_c2;
     double *mpP_Zc2;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     double *mpxin;
     //inputParameters pointers
     double *mpBf;
     double *mpCf;
     double *mpp0;
     double *mpT0;
     double *mpR;
     double *mpcv;
     double *mpeps;
     //outputVariables pointers
     double *mpqmP;
     double *mpqmN;
     Delay mDelayedPart10;
     Delay mDelayedPart20;
     Delay mDelayedPart30;
     Delay mDelayedPart40;
     Delay mDelayedPart50;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new PneumaticValve22();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(7,7);
        systemEquations.create(7);
        delayedPart.create(8,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpP1=addPowerPort("P1","NodePneumatic");
        mpP2=addPowerPort("P2","NodePneumatic");
        //Add inputVariables to the component
            addInputVariable("xin","Input signal 0<xin<1","",1,&mpxin);

        //Add inputParammeters to the component
            addInputVariable("Bf", "B, ISO critical pressure ratio", "", \
0.528,&mpBf);
            addInputVariable("Cf", "C, ISO flow coefficient", "", \
1.e-13,&mpCf);
            addInputVariable("p0", "Nominal pressure", "Pa", 100000.,&mpp0);
            addInputVariable("T0", "Nominal temperature", "K", 297.,&mpT0);
            addInputVariable("R", "Gas constant", "J/Kg K", 287.,&mpR);
            addInputVariable("cv", "heatcoeff", "J/Kg K", 718,&mpcv);
            addInputVariable("eps", "Linearisation coeff", "", 0.02,&mpeps);
        //Add outputVariables to the component
            addOutputVariable("qmP","Internal variable","kg/s",0.,&mpqmP);
            addOutputVariable("qmN","Internal variable","kg/s",0.,&mpqmN);

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,7);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port P1
        mpP_p1=getSafeNodeDataPtr(mpP1, NodePneumatic::Pressure);
        mpP_qm1=getSafeNodeDataPtr(mpP1, NodePneumatic::MassFlow);
        mpP_T1=getSafeNodeDataPtr(mpP1, NodePneumatic::Temperature);
        mpP_dE1=getSafeNodeDataPtr(mpP1, NodePneumatic::EnergyFlow);
        mpP_c1=getSafeNodeDataPtr(mpP1, NodePneumatic::WaveVariable);
        mpP_Zc1=getSafeNodeDataPtr(mpP1, NodePneumatic::CharImpedance);
        //Port P2
        mpP_p2=getSafeNodeDataPtr(mpP2, NodePneumatic::Pressure);
        mpP_qm2=getSafeNodeDataPtr(mpP2, NodePneumatic::MassFlow);
        mpP_T2=getSafeNodeDataPtr(mpP2, NodePneumatic::Temperature);
        mpP_dE2=getSafeNodeDataPtr(mpP2, NodePneumatic::EnergyFlow);
        mpP_c2=getSafeNodeDataPtr(mpP2, NodePneumatic::WaveVariable);
        mpP_Zc2=getSafeNodeDataPtr(mpP2, NodePneumatic::CharImpedance);

        //Read variables from nodes
        //Port P1
        p1 = (*mpP_p1);
        qm1 = (*mpP_qm1);
        T1 = (*mpP_T1);
        dE1 = (*mpP_dE1);
        c1 = (*mpP_c1);
        Zc1 = (*mpP_Zc1);
        //Port P2
        p2 = (*mpP_p2);
        qm2 = (*mpP_qm2);
        T2 = (*mpP_T2);
        dE2 = (*mpP_dE2);
        c2 = (*mpP_c2);
        Zc2 = (*mpP_Zc2);

        //Read inputVariables from nodes
        xin = (*mpxin);

        //Read inputParameters from nodes
        Bf = (*mpBf);
        Cf = (*mpCf);
        p0 = (*mpp0);
        T0 = (*mpT0);
        R = (*mpR);
        cv = (*mpcv);
        eps = (*mpeps);

        //Read outputVariables from nodes
        qmP = (*mpqmP);
        qmN = (*mpqmN);

//==This code has been autogenerated using Compgen==

        //LocalExpressions
        cp = cv + R;

        //Initialize delays

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];

        simulateOneTimestep();

     }
    void simulateOneTimestep()
     {
        Vec stateVar(7);
        Vec stateVark(7);
        Vec deltaStateVar(7);

        //Read variables from nodes
        //Port P1
        T1 = (*mpP_T1);
        c1 = (*mpP_c1);
        Zc1 = (*mpP_Zc1);
        //Port P2
        T2 = (*mpP_T2);
        c2 = (*mpP_c2);
        Zc2 = (*mpP_Zc2);

        //Read inputVariables from nodes
        xin = (*mpxin);

        //Read inputParameters from nodes
        Bf = (*mpBf);
        Cf = (*mpCf);
        p0 = (*mpp0);
        T0 = (*mpT0);
        R = (*mpR);
        cv = (*mpcv);
        eps = (*mpeps);

        //LocalExpressions
        cp = cv + R;

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = qmP;
        stateVark[1] = qmN;
        stateVark[2] = qm2;
        stateVark[3] = dE1;
        stateVark[4] = dE2;
        stateVark[5] = p1;
        stateVark[6] = p2;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //Valve22
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =qmP - \
Cf*p0*p1*Sqrt(T0/T1)*limit(xin,0,1)*(onNegative(-Bf + p1/p2)*onNegative(p1 - \
p2) + onNegative(-Bf + p2/p1)*onPositive(p1 - p2) + onPositive(p1 - \
p2)*onPositive(-Bf + p2/p1)*signedSquareL(1 - Power(-(Bf*p1) + \
p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps) + onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2)*signedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps));
          systemEquations[1] =qmN - \
Cf*p0*p2*Sqrt(T0/T2)*limit(xin,0,1)*(onNegative(-Bf + p1/p2)*onNegative(p1 - \
p2) + onNegative(-Bf + p2/p1)*onPositive(p1 - p2) + onPositive(p1 - \
p2)*onPositive(-Bf + p2/p1)*signedSquareL(1 - Power(-(Bf*p1) + \
p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps) + onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2)*signedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps));
          systemEquations[2] =qm2 + qmN*onNegative(p1 - p2) - \
qmP*onPositive(p1 - p2);
          systemEquations[3] =dE1 + cp*qm2*(T1*onNegative(-qm2) + \
T2*onPositive(-qm2));
          systemEquations[4] =dE2 - cp*qm2*(T2*onNegative(qm2) + \
T1*onPositive(qm2));
          systemEquations[5] =-c1 + p1 - dE1*Zc1;
          systemEquations[6] =-c2 + p2 - dE2*Zc2;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = 0;
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[0][4] = 0;
          jacobianMatrix[0][5] = \
-(Cf*p0*p1*Sqrt(T0/T1)*limit(xin,0,1)*((-2*(p1 - Bf*p2)*dxSignedSquareL(1 - \
Power(p1 - Bf*p2,2)/(Power(-1 + Bf,2)*Power(p2,2)),eps)*onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2))/(Power(-1 + Bf,2)*Power(p2,2)) + \
((2*Bf*(-(Bf*p1) + p2))/(Power(-1 + Bf,2)*Power(p1,2)) + (2*Power(-(Bf*p1) + \
p2,2))/(Power(-1 + Bf,2)*Power(p1,3)))*dxSignedSquareL(1 - Power(-(Bf*p1) + \
p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps)*onPositive(p1 - p2)*onPositive(-Bf \
+ p2/p1))) - Cf*p0*Sqrt(T0/T1)*limit(xin,0,1)*(onNegative(-Bf + \
p1/p2)*onNegative(p1 - p2) + onNegative(-Bf + p2/p1)*onPositive(p1 - p2) + \
onPositive(p1 - p2)*onPositive(-Bf + p2/p1)*signedSquareL(1 - Power(-(Bf*p1) \
+ p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps) + onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2)*signedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps));
          jacobianMatrix[0][6] = \
-(Cf*p0*p1*Sqrt(T0/T1)*limit(xin,0,1)*(((2*Bf*(p1 - Bf*p2))/(Power(-1 + \
Bf,2)*Power(p2,2)) + (2*Power(p1 - Bf*p2,2))/(Power(-1 + \
Bf,2)*Power(p2,3)))*dxSignedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps)*onNegative(p1 - p2)*onPositive(-Bf + p1/p2) - \
(2*(-(Bf*p1) + p2)*dxSignedSquareL(1 - Power(-(Bf*p1) + p2,2)/(Power(-1 + \
Bf,2)*Power(p1,2)),eps)*onPositive(p1 - p2)*onPositive(-Bf + \
p2/p1))/(Power(-1 + Bf,2)*Power(p1,2))));
          jacobianMatrix[1][0] = 0;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[1][4] = 0;
          jacobianMatrix[1][5] = \
-(Cf*p0*p2*Sqrt(T0/T2)*limit(xin,0,1)*((-2*(p1 - Bf*p2)*dxSignedSquareL(1 - \
Power(p1 - Bf*p2,2)/(Power(-1 + Bf,2)*Power(p2,2)),eps)*onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2))/(Power(-1 + Bf,2)*Power(p2,2)) + \
((2*Bf*(-(Bf*p1) + p2))/(Power(-1 + Bf,2)*Power(p1,2)) + (2*Power(-(Bf*p1) + \
p2,2))/(Power(-1 + Bf,2)*Power(p1,3)))*dxSignedSquareL(1 - Power(-(Bf*p1) + \
p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps)*onPositive(p1 - p2)*onPositive(-Bf \
+ p2/p1)));
          jacobianMatrix[1][6] = \
-(Cf*p0*p2*Sqrt(T0/T2)*limit(xin,0,1)*(((2*Bf*(p1 - Bf*p2))/(Power(-1 + \
Bf,2)*Power(p2,2)) + (2*Power(p1 - Bf*p2,2))/(Power(-1 + \
Bf,2)*Power(p2,3)))*dxSignedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps)*onNegative(p1 - p2)*onPositive(-Bf + p1/p2) - \
(2*(-(Bf*p1) + p2)*dxSignedSquareL(1 - Power(-(Bf*p1) + p2,2)/(Power(-1 + \
Bf,2)*Power(p1,2)),eps)*onPositive(p1 - p2)*onPositive(-Bf + \
p2/p1))/(Power(-1 + Bf,2)*Power(p1,2)))) - \
Cf*p0*Sqrt(T0/T2)*limit(xin,0,1)*(onNegative(-Bf + p1/p2)*onNegative(p1 - p2) \
+ onNegative(-Bf + p2/p1)*onPositive(p1 - p2) + onPositive(p1 - \
p2)*onPositive(-Bf + p2/p1)*signedSquareL(1 - Power(-(Bf*p1) + \
p2,2)/(Power(-1 + Bf,2)*Power(p1,2)),eps) + onNegative(p1 - \
p2)*onPositive(-Bf + p1/p2)*signedSquareL(1 - Power(p1 - Bf*p2,2)/(Power(-1 + \
Bf,2)*Power(p2,2)),eps));
          jacobianMatrix[2][0] = -onPositive(p1 - p2);
          jacobianMatrix[2][1] = onNegative(p1 - p2);
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[2][4] = 0;
          jacobianMatrix[2][5] = 0;
          jacobianMatrix[2][6] = 0;
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = cp*(T1*onNegative(-qm2) + \
T2*onPositive(-qm2));
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = 0;
          jacobianMatrix[3][5] = 0;
          jacobianMatrix[3][6] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = -(cp*(T2*onNegative(qm2) + \
T1*onPositive(qm2)));
          jacobianMatrix[4][3] = 0;
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = 0;
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = -Zc1;
          jacobianMatrix[5][4] = 0;
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[6][0] = 0;
          jacobianMatrix[6][1] = 0;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = 0;
          jacobianMatrix[6][4] = -Zc2;
          jacobianMatrix[6][5] = 0;
          jacobianMatrix[6][6] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          qmP=stateVark[0];
          qmN=stateVark[1];
          qm2=stateVark[2];
          dE1=stateVark[3];
          dE2=stateVark[4];
          p1=stateVark[5];
          p2=stateVark[6];
        //Expressions
        qm1 = -qm2;
        }

        //Calculate the delayed parts

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];

        //Write new values to nodes
        //Port P1
        (*mpP_p1)=p1;
        (*mpP_qm1)=qm1;
        (*mpP_dE1)=dE1;
        //Port P2
        (*mpP_p2)=p2;
        (*mpP_qm2)=qm2;
        (*mpP_dE2)=dE2;
        //outputVariables
        (*mpqmP)=qmP;
        (*mpqmN)=qmN;

        //Update the delayed variabels

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // PNEUMATICVALVE22_HPP_INCLUDED
